<!DOCTYPE html>
<html lang="en">
<head>
<title>Image Editor</title>
<style id="css">
button, body, select, input {
	background-color: rgb(40, 40, 40);
}
button, body, a, p, h1, select, option, input {
	color: white;
}
</style>
</head>
<body>
Background Color: <input id="bgcolor" type="color">
<h1>Image Editor</h1>
<input id="image" type="file" accept=".jfif, .jpeg, .jpg, .png, .webp, .gif, .bmp, .svg, .cur, .avif, .ico, .apng, .tga"><br><a>File Treaty Type:</a><select id="treatimage"><option value="att">Attempt to decode the image data</option><option value="asa">Assume the file data is raw RGBA image data</option><option value="asb">Assume the file data is raw RGB image data</option><option value="asd">Assume the file data is raw grayscale image data</option><option value="asv">Attempt to decode the video data (and extract any frame selected)</option></select>
<hr>
<canvas id="canvas" width="300" height="300"></canvas>
<hr>
<select id="effects"><option>Please select an effect.</option><option value="restore">Restore Image</option><option value="tint">Tint (Filter Color)</option><option value="tintblend">Tint (Blend Color)</option><option value="shift">Shift</option><option value="backg">Apply Background</option><option value="gblur">Gaussian Blur</option><option value="crop">Crop</option><option value="inv">Invert Colors</option><option value="sharpg">High Contrast</option><option value="sepia">Sepia</option><option value="graya">Grayscale (By Average)</option><option value="grayb">Grayscale (By Brightness)</option><option value="grayc">Grayscale (By Color Channel)</option><option value="contr">Contrast</option><option value="flipx">Flip Horizontally</option><option value="flipy">Flip Vertically</option><option value="rgbsh">Shift RGB Colors To The Left</option><option value="rgbre">Reverse Order Of RGB Colors</option><option value="resi">Resize Image</option><option value="parag">Resize Image Without Aligning Columns</option><option value="resid">Resize Image Dimensions</option><option value="opac">Set Opacity</option><option value="jpeg">JPEG-ify</option><option value="webp">WEBP-ify</option><option value="minip">Minimize Color Palette</option><option value="jpegd">Image Distortion Animation</option><option value="rect">Draw Rectangle</option><option value="mp3">MP3-ify</option></select><button id="apply">Apply Effect</button>
<div id="configs"></div>
<script>
// tga.js
const TYPE_NO_DATA=0,TYPE_INDEXED=1,TYPE_RGB=2,TYPE_GREY=3,TYPE_RLE_INDEXED=9,TYPE_RLE_RGB=10,TYPE_RLE_GREY=11,ORIGIN_BOTTOM_LEFT=0,ORIGIN_BOTTOM_RIGHT=1,ORIGIN_TOP_LEFT=2,ORIGIN_TOP_RIGHT=3,ORIGIN_SHIFT=4,ORIGIN_MASK=48;class TgaLoader{_checkHeader(){const e=this.header;if(0===e.imageType)throw new Error("No data");if(e.hasColorMap){if(e.colorMapLength>256||24!==e.colorMapDepth||1!==e.colorMapType)throw new Error("Invalid colormap for indexed type")}else if(e.colorMapType)throw new Error("Why does the image contain a palette?");if(!e.width||!e.height)throw new Error("Invalid image size");if(8!==e.pixelDepth&&16!==e.pixelDepth&&24!==e.pixelDepth&&32!==e.pixelDepth)throw new Error('Invalid pixel size "'+e.pixelDepth+'"')}_decodeRLE(e,t,a,r){const o=new Uint8Array(r),i=new Uint8Array(a);let s=0;for(;s<r;){const r=e[t++];let h=1+(127&r);if(128&r){for(let r=0;r<a;++r)i[r]=e[t+r];t+=a;for(let e=0;e<h;++e)o.set(i,s),s+=a}else{h*=a;for(let a=0;a<h;++a)o[s+a]=e[t+a];s+=h,t+=h}}return o}_getImageData8bits(e,t,a,r,o,i,s,h,n,g){for(let l=0,p=o;p!==s;p+=i)for(let o=h;o!==g;o+=n,l++){const i=t[l];e[4*(o+r*p)+3]=255,e[4*(o+r*p)+2]=a[3*i+0],e[4*(o+r*p)+1]=a[3*i+1],e[4*(o+r*p)+0]=a[3*i+2]}return e}_getImageData16bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=2){const i=t[a+0]|t[a+1]<<8;e[4*(o+r*l)+0]=(31744&i)>>7,e[4*(o+r*l)+1]=(992&i)>>2,e[4*(o+r*l)+2]=(31&i)>>3,e[4*(o+r*l)+3]=32768&i?0:255}return e}_getImageData24bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=3)e[4*(o+r*l)+3]=255,e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+1]=t[a+1],e[4*(o+r*l)+0]=t[a+2];return e}_getImageData32bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=4)e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+1]=t[a+1],e[4*(o+r*l)+0]=t[a+2],e[4*(o+r*l)+3]=t[a+3];return e}_getImageDataGrey8bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a++){const i=t[a];e[4*(o+r*l)+0]=i,e[4*(o+r*l)+1]=i,e[4*(o+r*l)+2]=i,e[4*(o+r*l)+3]=255}return e}_getImageDataGrey16bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=2)e[4*(o+r*l)+0]=t[a+0],e[4*(o+r*l)+1]=t[a+0],e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+3]=t[a+1];return e}open(e,t){const a=new XMLHttpRequest;a.responseType="arraybuffer",a.open("GET",e,!0),a.onload=()=>{200===a.status&&(this.load(new Uint8Array(a.response)),t&&t())},a.send(null)}load(e){let t=0;if(e.length<18)throw new Error("Not enough data to contain header");const a={idLength:e[t++],colorMapType:e[t++],imageType:e[t++],colorMapIndex:e[t++]|e[t++]<<8,colorMapLength:e[t++]|e[t++]<<8,colorMapDepth:e[t++],offsetX:e[t++]|e[t++]<<8,offsetY:e[t++]|e[t++]<<8,width:e[t++]|e[t++]<<8,height:e[t++]|e[t++]<<8,pixelDepth:e[t++],flags:e[t++]};if(a.hasEncoding=9===a.imageType||10===a.imageType||11===a.imageType,a.hasColorMap=9===a.imageType||1===a.imageType,a.isGreyColor=11===a.imageType||3===a.imageType,this.header=a,this._checkHeader(),t+=a.idLength,t>=e.length)throw new Error("No data");if(a.hasColorMap){const r=a.colorMapLength*(a.colorMapDepth>>3);this.palette=e.subarray(t,t+r),t+=r}const r=a.pixelDepth>>3,o=a.width*a.height,i=o*r;a.hasEncoding?this.imageData=this._decodeRLE(e,t,r,i):this.imageData=e.subarray(t,t+(a.hasColorMap?o:i))}getImageData(e){const{width:t,height:a,flags:r,pixelDepth:o,isGreyColor:i}=this.header,s=(48&r)>>4;let h,n,g,l,p,c,d;switch(e||(e=document?document.createElement("canvas").getContext("2d").createImageData(t,a):{width:t,height:a,data:new Uint8ClampedArray(t*a*4)}),2===s||3===s?(l=0,p=1,c=a):(l=a-1,p=-1,c=-1),2===s||0===s?(h=0,n=1,g=t):(h=t-1,n=-1,g=-1),o){case 8:d=i?this._getImageDataGrey8bits:this._getImageData8bits;break;case 16:d=i?this._getImageDataGrey16bits:this._getImageData16bits;break;case 24:d=this._getImageData24bits;break;case 32:d=this._getImageData32bits}return d.call(this,e.data,this.imageData,this.palette,t,l,p,c,h,n,g),e}getCanvas(){const{width:e,height:t}=this.header,a=document.createElement("canvas"),r=a.getContext("2d"),o=r.createImageData(e,t);return a.width=e,a.height=t,r.putImageData(this.getImageData(o),0,0),a}getDataURL(e){return this.getCanvas().toDataURL(e||"image/png")}};

/* dds.js
const gl = document.createElement("canvas").getContext("webgl");

const DDS_MAGIC = "DDS ";
const DX10_MAGIC = "DX10";  // Added DX10 magic constant
const DDS_HEADER_SIZE = 124; // Fixed size for standard DDS header

// Constants for DDS flags and formats
const DDSF_CAPS = 1;
const DDSF_HEIGHT = 2;
const DDSF_WIDTH = 4;
const DDSF_PIXELFORMAT = 4096;
const DDSF_MIPMAPCOUNT = 131072;
const DDSF_FOURCC = 4;
const DDSF_RGBA = 65;
const DDSF_RGB = 64;

const FOURCC = {
  DXT1: 827611204, DXT5: 894720068, R8G8B8: 20, RGB32: 1145194322, 
  RGBA32: 1178748754, RGB24: 910313298
};

const fourccFormats = {
  [FOURCC.DXT1]: compressedFormat(gl.COMPRESSED_RGBA_S3TC_DXT1_EXT, 8),
  [FOURCC.DXT5]: compressedFormat(gl.COMPRESSED_RGBA_S3TC_DXT5_EXT, 16),
  [FOURCC.R8G8B8]: format(gl.BGR, gl.RGB8, gl.UNSIGNED_BYTE, 3),
  [FOURCC.RGB32]: format(gl.RGB, gl.RGBA8, gl.UNSIGNED_BYTE, 4),
  [FOURCC.RGBA32]: format(gl.RGBA, gl.RGBA8, gl.UNSIGNED_BYTE, 4),
  [FOURCC.RGB24]: format(gl.BGR, gl.RGB8, gl.UNSIGNED_BYTE, 3)
};

// Helper functions to define format and compressed format
function format(t, e, r, a) {
  return { format: t, internal_format: e, type: r, bytesPerElement: a, compressed: false };
}

function compressedFormat(t, e) {
  return { format: t, internal_format: t, type: t, bytesPerElement: e, compressed: true };
}

// Main function to parse DDS file
function parseDDS(arrayBuffer) {
  if (!(arrayBuffer instanceof ArrayBuffer)) {
    throw new Error("Expected ArrayBuffer");
  }

  const bytes = new Uint8Array(arrayBuffer);

  // Validate DDS Magic String
  if (new TextDecoder().decode(bytes.slice(0, 4)) !== DDS_MAGIC) {
    return {error: Error("Not a valid DDS file")};
  }

  const header = unpackDDSHeader(bytes);
  const formatInfo = getFormatInfo(header);
  
  let result = {
    width: header.width,
    height: header.height,
    depth: header.caps2 & 1 ? header.depth : 0,
    levels: (header.flags & DDSF_MIPMAPCOUNT) ? header.mipMapCount : 1,
    parts: []
  };

  Object.assign(result, formatInfo);

  // Calculate mipmap levels
  let width = result.width;
  let height = result.height;
  let depth = result.depth || 1;
  let offset = 4 + DDS_HEADER_SIZE;  // Start offset after the header

  for (let level = 0; level < result.levels; level++) {
    const size = Math.max(1, Math.floor(width / 2)) * Math.max(1, Math.floor(height / 2)) * depth * result.bytesPerElement;
    result.parts.push({ offset, size });
    offset += size;
    width = Math.max(1, Math.floor(width / 2));
    height = Math.max(1, Math.floor(height / 2));
  }

  return result;
}

// Unpack the DDS header
function unpackDDSHeader(bytes) {
  const view = new DataView(bytes.buffer);
  const header = {
    width: view.getUint32(4, false),
    height: view.getUint32(8, false),
    flags: view.getUint32(12, true),
    pf_flags: view.getUint32(20, true),
    pf_fourCC: view.getUint32(84, true),
    pf_rgbBitCount: view.getUint32(28, true),
    mipMapCount: view.getUint32(104, true),
    caps1: view.getUint32(108, true),
    caps2: view.getUint32(112, true),
    size: view.getUint32(0, true)
  };

  // Check for DX10 extended header
  if (new TextDecoder().decode(bytes.slice(0, 4)) === DX10_MAGIC) {
    // Parse DX10 header (additional fields)
    header.isDX10 = true;
    // For simplicity, let's assume DX10 header starts at byte 124
    const dx10View = new DataView(bytes.buffer, DDS_HEADER_SIZE);
    header.dx10Format = dx10View.getUint32(0, true);
    header.arraySize = dx10View.getUint32(4, true);
    header.miscFlags = dx10View.getUint32(8, true);
    // Any other DX10-specific parsing can go here...
  }

  return header;
}

// Interpret the format based on flags and FOURCC
function getFormatInfo(header) {
  let formatInfo = null;

  if (header.pf_flags & DDSF_FOURCC) {
    formatInfo = fourccFormats[header.pf_fourCC];
  } else if (header.pf_flags === DDSF_RGBA && header.pf_rgbBitCount === 32) {
    formatInfo = fourccFormats[FOURCC.RGBA32];
  } else if (header.pf_flags === DDSF_RGB && header.pf_rgbBitCount === 32) {
    formatInfo = fourccFormats[FOURCC.RGB32];
  } else if (header.pf_flags === DDSF_RGB && header.pf_rgbBitCount === 24) {
    formatInfo = fourccFormats[FOURCC.RGB24];
  }

  if (!formatInfo) {
     return {...formatInfo, error: Error(`Unknown DDS format: pf_flags=${header.pf_flags}, pf_fourCC=${header.pf_fourCC}, pf_rgbBitCount=${header.pf_rgbBitCount}`)};
  }

  return formatInfo;
}
*/ // end dds.js

function loadTgaFromUint8Array(tgaData) {
	let buffer, image;
	try {
		const loader = new TgaLoader();
		loader.load(tgaData);
		image = loader.imageData;
		const possibleInstructions = [
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_BOTTOM_LEFT,
				"flip the image vertically."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_BOTTOM_RIGHT,
				"flip the image horizontally, and flip the image vertically."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_TOP_LEFT,
				"reverse the color channels' order, or shift the color channels' to the left repeatedly until the image's color feels right to you."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_TOP_RIGHT,
				"flip the image horizontally."
			]
		];
		let instructions = possibleInstructions.find(x => x[0])[1];
		alert("Proper handling for the TGA origins and different color orders will come in a future update. For now, you must " + instructions + (instructions === "reverse the color channels' order, or shift the color channels' to the left repeatedly until the image's color feels right to you." ? "" : " You may also need to shift the color channels until the image's color feels right to you."));
		if (loader.header.pixelDepth === 24) {
			buffer = new Uint8ClampedArray(loader.header.width * loader.header.height * 4);
			for (let i = 0, j = 0; i < buffer.length;) {
				buffer[i] = image[j]; i++, j++;
				buffer[i] = image[j]; i++, j++;
				buffer[i] = image[j]; i++, j++;
				buffer[i] = 255; i++;
			}
			return new ImageData(
				buffer,
				loader.header.width,
				loader.header.height
			);
		} else if (loader.header.pixelDepth === 32) {
			return new ImageData(
				image,
				loader.header.width,
				loader.header.height
			);
		}
	} catch (err) {
		alert("There has been an error trying to decode the TGA image: " + err.message);
		if (tgaData.length === 0) alert("The TGA image contains no file data at all. This is needed to provide the context of the image (e.g. the width, height, color channels, etc), and the image data itself.");
		else if ((loader.header.pixelDepth === 24 && image.length !== loader.header.width * loader.header.height * 3) || (loader.header.pixelDepth === 32 && image.length !== loader.header.width * loader.header.height * 4)) alert("There appears to be an image data overflow (providing too many pixel values) or underflow (providing too little pixel values). This has to be fixed, so the image can correctly be loaded next time.");
		else if ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
			if (confirm("The TGA image has a very odd specification of the pixel depth (provided was " + loader.header.pixelDepth + ", expected was 8, 16, 24, or 32). Do you want to provide the pixel depth?")) {
				//16
				let pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
				if ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
					while ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
						alert("That level isn't recommended; you need to specify again.");
						pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
					}
				}
				tgaData[16] = Math.round(pixelDepth & 256);
				loadTgaFromUint8Array(tgaData);
			}
		}
	}
}

/* function loadDdsFromUint8Array(ddsData) {
	let buffer, image, ddsFileInfo;
	try {
		// Parse DDS file
		ddsFileInfo = parseDDS(ddsData);
		if (ddsFileInfo.error) throw ddsFileInfo.error;

		// User selects mipmap level
		const mipmapIndex = Math.floor(Math.max(0, Math.min(ddsFileInfo.parts.length - 1, +prompt(
			`Select a mipmap level (there are ${ddsFileInfo.parts.length} mipmaps available). ` +
			`Select an index (zero-based) or use 0 for the highest resolution level.`)) || 0));
		
		image = ddsFileInfo.parts[mipmapIndex];
		
		// Handle specific DDS formats
		if (ddsFileInfo.pf_rgbBitCount === 24 && (ddsFileInfo.format === gl.BGR && ddsFileInfo.internal_format === gl.RGB8)) {
			// Convert BGR to RGBA (add alpha channel)
			buffer = new Uint8ClampedArray(ddsFileInfo.header.width * ddsFileInfo.header.height * 4);
			let i = 0;
			for (let j = 0; i < buffer.length; j += 3) {
				// Swap R and B channels (since it's BGR) and add alpha channel as 255
				buffer[i] = image[j + 2]; i++;  // R
				buffer[i] = image[j + 1]; i++;  // G
				buffer[i] = image[j]; i++;      // B
				buffer[i] = 255; i++;           // Alpha (fully opaque)
			}
			return new ImageData(buffer, ddsFileInfo.header.width, ddsFileInfo.header.height);

		} else if (ddsFileInfo.pf_rgbBitCount === 32 && (ddsFileInfo.format === gl.RGB && ddsFileInfo.internal_format === gl.RGBA8)) {
			// No conversion needed for RGBA8 format
			return new ImageData(image, ddsFileInfo.header.width, ddsFileInfo.header.height);

		} else {
			// Handle unsupported formats
			alert("Unknown colorspace for the DDS image - this case will be handled in the future.");
		}
	} catch (err) {
		alert("Error decoding the DDS image: " + err.message);

		console.log(ddsFileInfo);
		
		// Specific checks for potential issues
		if (ddsData.length === 0) {
			alert("The DDS file is empty. This image requires data for width, height, channels, etc.");
		} else if ((ddsFileInfo.pf_rgbBitCount === 24 && image.length !== ddsFileInfo.width * ddsFileInfo.height * 3) || 
			(ddsFileInfo.pf_rgbBitCount === 32 && image.length !== ddsFileInfo.width * ddsFileInfo.height * 4)) {
			alert("Image data overflow or underflow: the provided pixel data does not match the expected dimensions.");
		} else if (![24, 32].includes(ddsFileInfo.pf_rgbBitCount)) {
			// Handle unexpected pixel depth
			if (confirm("Unexpected pixel depth in DDS image (" + ddsFileInfo.pf_rgbBitCount + "). Would you like to provide the pixel depth?")) {
				let pixelDepth = +prompt("Provide the pixel depth (default is 24).") || 24;
				while (![24, 32].includes(pixelDepth)) {
					alert("Unsupported pixel depth. Please choose 24 or 32.");
					pixelDepth = +prompt("Provide the pixel depth (default is 24).") || 24;
				}
				// Update the pixel depth
				ddsData[28] = Math.round(pixelDepth & 256);
				ddsData[29] = 0;
				ddsData[30] = 0;
				ddsData[31] = 0;
				// Assuming this function exists
				loadDdsFromUint8Array(ddsData);
			}
		}
	}
} */

const fileInput = document.getElementById("image"), treatFile = document.getElementById("treatimage"), canvas = document.getElementById("canvas"), effects = document.getElementById("effects"), applyEffect = document.getElementById("apply"), effectSettings = document.getElementById("configs");
const context = canvas.getContext("2d");
if (!context) {
	alert("Your browser does not support the 2D canvas context yet. Either upgrade to a newer version of your browser, or try using a different one.");
}
	let currentImageData = new ImageData(new Uint8ClampedArray(300 * 300 * 4), 300, 300), backupImageData = new ImageData(new Uint8ClampedArray(300 * 300 * 4), 300, 300), originalImage;
	fileInput.addEventListener("input", function(event) {
		const file = event.target.files[0];
		let fileReader = new FileReader();
		fileReader.onload = function(res) {
			if (treatFile.value === "att") {
				if (file.name.endsWith(".tga")) {
					alert("TGA.js is being used to decode the image. (Borrowed code from https://github.com/vthibault/tga.js/blob/master/src/tga.js - later modified to fit this editor's standards)");
					currentImageData = loadTgaFromUint8Array(new Uint8Array(res.target.result));
					backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
					canvas.width = currentImageData.width;
					canvas.height = currentImageData.height;
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					context.putImageData(currentImageData, 0, 0);
				}/* else if (file.name.endsWith(".dds")) {
					alert("DDS.js (browser port) is being used to decode the image.");
					currentImageData = loadDdsFromUint8Array(res.target.result);
					backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
					canvas.width = currentImageData.width;
					canvas.height = currentImageData.height;
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					context.putImageData(currentImageData, 0, 0);
				}*/ else {
					const img = new Image();
					img.onload = function() {
						canvas.width = img.width;
						canvas.height = img.height;
						context.clearRect(0, 0, +canvas.width, +canvas.height);
						context.drawImage(img, 0, 0, +canvas.width, +canvas.height);
						currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						originalImage = img;
					}
					img.src = res.target.result;
				}
			} else {
				if (treatFile.value !== "asv") {
					const width = Math.round(+(prompt("What should the width of the raw file data be for the final image? (The height is automatically determined. The default value is 300)") || 300));
					if (treatFile.value === "asa") {
						const height = Math.ceil(res.target.result.byteLength / width / 4);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4);
						roundedUint.set(new Uint8ClampedArray(res.target.result));
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					} else if (treatFile.value === "asb") {
						const height = Math.ceil(res.target.result.byteLength / width / 3);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4), buff = new Uint8ClampedArray(res.target.result);
						let byte = 0;
						for (let i = 0; i < roundedUint.byteLength;) {
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = 255; i++;
						}
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					} else if (treatFile.value === "asd") {
						const height = Math.ceil(res.target.result.byteLength / width);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4), buff = new Uint8ClampedArray(res.target.result);
						let first = 0;
						for (let i = 0; i < roundedUint.byteLength;) {
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = 255; i++; first++;
						}
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					}
				} else {
					fileInput.style.display = "none";
					const video = document.createElement("video");
					video.oncanplaythrough = function() {
						video.oncanplaythrough = function() {}
						setTimeout(function() {
							canvas.width = video.width;
							canvas.height = video.height;
							canvas.style.display = "none";
							context.clearRect(0, 0, +canvas.width, +canvas.height);
							video.ontimeupdate = function() {
								context.drawImage(video, 0, 0, +canvas.width, +canvas.height);
							}
							document.body.appendChild(video);
							const bounding = video.getBoundingClientRect();
							if (canvas.width == 0 || canvas.height == 0) {
								canvas.width = bounding.width;
								canvas.height = bounding.height;
							}
							video.controls = true;
							const confirm = document.createElement("button");
							confirm.textContent = "Select Frame";
							document.body.appendChild(confirm);
							confirm.onclick = function() {
								video.pause();
								video.muted = true;
								confirm.onclick = function() {};
								setTimeout(function() {
									canvas.style.display = "";
									currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
									backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
									const image = new Image();
									image.src = canvas.toDataURL("image/png");
									originalImage = image;
									video.src = "";
									video.remove();
									fileInput.style.display = "";
									confirm.remove();
								}, 200);
							}
						}, 1000);
					}
					video.src = res.target.result;
				}
			}
		}
		if ((treatFile.value === "att" || treatFile.value === "asv") && !file.name.endsWith(".tga") /*&& !file.name.endsWith(".dds")*/) fileReader.readAsDataURL(file); else fileReader.readAsArrayBuffer(file);
	});
	treatFile.oninput = function() {
		if (treatFile.value === "att") fileInput.accept = ".jfif, .jpeg, .jpg, .png, .webp, .gif, .bmp, .svg, .cur, .avif, .ico, .apng, .tga"; else if (treatFile.value === "asv") fileInput.accept = ".mp4, .ogg, .webm, .3gp"; else fileInput.accept = ".*";
	}
	let effectParams = [];
	function extractRGBA(hex, a) {
		const r = parseInt(hex.slice(1, 3), 16) / 255;
		const g = parseInt(hex.slice(3, 5), 16) / 255;
		const b = parseInt(hex.slice(5, 7), 16) / 255;
		return [r, g, b, a];
	}
	function extractRGBA2(hex, a) {
		const r = parseInt(hex.slice(1, 3), 16);
		const g = parseInt(hex.slice(3, 5), 16);
		const b = parseInt(hex.slice(5, 7), 16);
		return [r, g, b, a];
	}
	function interpolate(x, y, n) {
		return x + (y - x) * n;
	}
	function applyGaussianBlur(imageData, kernel) {
		const width = imageData.width;
		const height = imageData.height;
		const output = new ImageData(new Uint8ClampedArray(width * height * 4), width, height);
		const kernelSize = kernel.length;
		const halfKernel = Math.floor(kernelSize / 2);
		const data = output.data;
		let r, g, b, a, outputIndex, px, py, pixelIndex, weight;
		for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				r = 0, g = 0, b = 0, a = 0;
				for (let ky = 0; ky < kernelSize; ky++) {
					for (let kx = 0; kx < kernelSize; kx++) {
						px = x + kx - halfKernel;
						py = y + ky - halfKernel;
						if (px >= 0 && py >= 0 && px < width && py < height) {
							pixelIndex = (py * width + px) * 4;
							weight = kernel[ky][kx];
							r += imageData.data[pixelIndex] * weight; pixelIndex++;
							g += imageData.data[pixelIndex] * weight; pixelIndex++;
							b += imageData.data[pixelIndex] * weight; pixelIndex++;
							a += imageData.data[pixelIndex] * weight;
						}
					}
				}
				outputIndex = (y * width + x) * 4;
				data[outputIndex] = r; outputIndex++;
				data[outputIndex] = g; outputIndex++;
				data[outputIndex] = b; outputIndex++;
				data[outputIndex] = a;
			}
		}
		return output;
	}
	function generateGaussianKernel(sigma, size) {
		const kernel = [];
		const mean = Math.floor(size / 2);
		let sum = 0, dx, dy, value;
		for (let y = 0; y < size; y++) {
			kernel[y] = [];
			for (let x = 0; x < size; x++) {
				dx = x - mean;
				dy = y - mean;
				value = (1 / (2 * Math.PI * sigma * sigma)) * Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
				kernel[y][x] = value;
				sum += value;
			}
		}
		for (let y = 0; y < size; y++) {
			for (let x = 0; x < size; x++) {
				kernel[y][x] /= sum;
			}
		}
		return kernel;
	}
	function mod(x, y) {
		let result = x % y;
		return result < 0 ? result + y : result;
	}
	function chooseEffect() {
		effectSettings.innerHTML = "";
		if (effects.value === "tint") {
			effectSettings.innerHTML = "<a>Tint Color:</a><input type=\"color\" value=\"#FF0000\" id=\"e-tintcolor\"><br><a>Tint Opacity:</a><input type=\"number\" value=\"1\" min=\"0\" max=\"1\" step=\"0.00390625\" id=\"e-tintopac\"><br><a>Tint Multiplier:</a><input type=\"number\" value=\"1\" min=\"0\" max=\"255\" step=\"1\" id=\"e-tintmult\">";
			effectParams = [document.getElementById("e-tintcolor"), document.getElementById("e-tintopac"), document.getElementById("e-tintmult")];
		} else if (effects.value === "tintblend") {
			effectSettings.innerHTML = "<a>Tint Color:</a><input type=\"color\" value=\"#FF0000\" id=\"e-tintcolor\"><br><a>Blending Percentage:</a><input type=\"number\" value=\"20\" min=\"0\" max=\"100\" step=\"1\" id=\"e-tintopac\">";
			effectParams = [document.getElementById("e-tintcolor"), document.getElementById("e-tintopac")];
		} else if (effects.value === "shift") {
			effectSettings.innerHTML = "<a>Direction (in pixels. negative = leftwards, positive = rightwards):</a><input type=\"number\" value=\"0\" id=\"e-shiftdir\"><br><a>Color Padding:</a><input type=\"color\" value=\"#000000\" id=\"e-shiftcolor\"><br><a>Color Padding Opacity:</a><input type=\"number\" value=\"0\" min=\"0\" max=\"1\" step=\"0.00390625\" id=\"e-shiftopac\"><br><a>Wrap Around Image:</a><input type=\"checkbox\" id=\"e-shiftwrap\"><br><a>(if enabled) Pixel Level (if disabled) Integral Level:</a><input type=\"checkbox\" id=\"e-shiftint\" checked>";
			effectParams = [document.getElementById("e-shiftdir"), document.getElementById("e-shiftcolor"), document.getElementById("e-shiftopac"), document.getElementById("e-shiftwrap"), document.getElementById("e-shiftint")];
		} else if (effects.value === "backg") {
			effectSettings.innerHTML = "<a>Background Color:</a><input type=\"color\" value=\"#000000\" id=\"e-backcolor\">";
			effectParams = [document.getElementById("e-backcolor")];
		} else if (effects.value === "gblur" || effects.value === "sharpg") {
			effectSettings.innerHTML = "<a>Kernel Size (Slight Blur Spread, and Smoothness):</a><input type=\"number\" value=\"3\" step=\"2\" min=\"1\" max=\"15\" id=\"e-gblurkernel\"><br><a>Sigma Value:</a><input type=\"number\" value=\"1\" step=\"0.1\" min=\"0\" max=\"100\" id=\"e-gblursigma\">";
			effectParams = [document.getElementById("e-gblurkernel"), document.getElementById("e-gblursigma")];
		} else if (effects.value === "crop" || effects.value === "rect") {
			effectSettings.innerHTML = "<a>X:</a><input type=\"number\" value=\"0\" id=\"e-cropx\"><br><a>Y:</a><input type=\"number\" value=\"0\" id=\"e-cropy\"><br><a>Width:</a><input type=\"number\" value=\"0\" id=\"e-cropw\"><br><a>Height:</a><input type=\"number\" value=\"0\" id=\"e-croph\"><br><a>" + (effects.value === "rect" ? "Rectangle" : "Highlight") + " Color:</a><input type=\"color\" value=\"#ffffff\" id=\"e-cropc\">" + (effects.value === "rect" ? "<br><a>Rectangle Opacity:</a><input type=\"number\" value=\"1\" step=\"0.01\" min=\"0\" max=\"1\" id=\"e-recto\">" : "");
			effectParams = [document.getElementById("e-cropx"), document.getElementById("e-cropy"), document.getElementById("e-cropw"), document.getElementById("e-croph"), document.getElementById("e-cropc"), document.getElementById("e-recto")];
			for (const p of effectParams) {
				p.oninput = function() {
					if (p.type !== "color") {
						if (p.id === "e-recto") p.value = String(+p.value.trim()); else p.value = String(Math.round(+p.value.trim()));
					}
					context.putImageData(currentImageData, 0, 0);
					context.fillStyle = "rgba(" + extractRGBA2(effectParams[4].value, 0.3).join(", ") + ")";
					context.fillRect(+effectParams[0].value, +effectParams[1].value, +effectParams[2].value, +effectParams[3].value);
				}
			}
		} else if (effects.value === "inv" || effects.value === "sepia" || effects.value === "graya" || effects.value === "grayb" || effects.value === "rgbsh" || effects.value === "rgbre") {
			effectSettings.innerHTML = "<a>Progress (as a percentage):</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-invpro\">%";
			effectParams = [document.getElementById("e-invpro")];
		} else if (effects.value === "resi" || effects.value === "parag" || effects.value === "resid") {
			effectSettings.innerHTML = "<a>Width:</a><input type=\"number\" value=\"\" id=\"e-resiw\"><br><a>Height:</a><input type=\"number\" value=\"\" id=\"e-resih\">" + (effects.value === "resi" ? "<br><a>Anti-aliasing:</a><input type=\"checkbox\" checked id=\"e-resia\">" : "");
			effectParams = [document.getElementById("e-resiw"), document.getElementById("e-resih"), effects.value === "resi" ? document.getElementById("e-resia") : null];
			effectParams[0].value = canvas.width;
			effectParams[1].value = canvas.height;
		} else if (effects.value === "contr") {
			effectSettings.innerHTML = "<a>Contrast Level:</a><input type=\"number\" value=\"0.5\" step=\"0.02\" min=\"0\" max=\"10\" id=\"e-contr\">";
			effectParams = [document.getElementById("e-contr")];
		} else if (effects.value === "grayc") {
			effectSettings.innerHTML = "<a>Progress (as a percentage):</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-graypro\">%<br><a>R Grayscale Multiplier:</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-grayr\">%<br><a>G Grayscale Multiplier:</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-grayg\">%<br><a>B Grayscale Multiplier:</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-grayb\">%";
			effectParams = [document.getElementById("e-graypro"), document.getElementById("e-grayr"), document.getElementById("e-grayg"), document.getElementById("e-grayb")];
		} else if (effects.value === "opac") {
			effectSettings.innerHTML = "<a>Transparency (as a percentage):</a><input type=\"number\" value=\"0\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-opactr\"><a id=\"percent\">%</a><br><a>Act As Opacity Multiplier:</a><input type=\"checkbox\" id=\"e-opacmu\">";
			effectParams = [document.getElementById("e-opactr"), document.getElementById("e-opacmu")];
			let x = document.getElementById("percent");
			effectParams[1].oninput = function() {
				x.textContent = effectParams[1].checked ? "x" : "%";
				effectParams[0].step = effectParams[1].checked ? "0.01" : "0.390625";
				effectParams[0].max = effectParams[1].checked ? "10" : "100";
				effectParams[0].value = effectParams[1].checked ? +effectParams[0].value / 100 : +effectParams[0].value * 100;
			}
		} else if (effects.value === "jpeg" || effects.value === "webp" || effects.value === "avif") {
			effectSettings.innerHTML = "<a>Quality:</a><input type=\"number\" value=\"80\" step=\"1\" min=\"1\" max=\"100\" id=\"e-jpegq\">";
			effectParams = [document.getElementById("e-jpegq")];
		} else if (effects.value === "minip") {
			effectSettings.innerHTML = "<a>Palette Reduction:</a><input type=\"number\" value=\"16\" step=\"1\" min=\"1\" max=\"256\" id=\"e-minipq\">";
			effectParams = [document.getElementById("e-minipq")];
		} else if (effects.value === "jpegd") {
			effectSettings.innerHTML = "<a>Effect Interval:</a><input type=\"number\" value=\"0.05\" step=\"0.01\" min=\"0\" max=\"10\" id=\"e-jpegdint\">";
			effectParams = [document.getElementById("e-jpegdint")];
		} else if (effects.value === "mp3") {
			effectSettings.innerHTML = "<a>Bitrate:</a><input type=\"number\" value=\"128\" step=\"16\" min=\"32\" max=\"320\" id=\"e-mp3bitrate\"><br><a>This effect is unconventional. First, the image data is directly encoded using <a href=\"https://github.com/webpack-contrib/lamejs\">lamejs</a> with the chosen bitrate, then the MP3 data is decoded back into the image. THIS PROCESS MAY BE COMPUTATIONALLY EXPENSIVE FOR LARGER IMAGES!</a>";
			effectParams = [document.getElementById("e-mp3bitrate")];
		} else {
			effectSettings.innerHTML = "";
			effectParams = [];
		}
	}
	effects.oninput = chooseEffect;
	apply.onclick = async function() {
		const imageData = currentImageData.data;
		let len = imageData.length;
		switch (effects.value) {
			case "tint": {
				let i = 0, tintColor = extractRGBA(effectParams[0].value, Math.max(0, Math.min(1, +effectParams[1].value)));
				tintColor = tintColor.map(x => x * +effectParams[2].value);
				if (tintColor[0] === 1 && tintColor[1] === 1 && tintColor[2] === 1) {
					if (tintColor[3] !== 1) {
						for (i = 3; i < len; i += 4) {
							imageData[i] *= tintColor[3];
						}
					}
				} else {
					for (; i < len;) {
						imageData[i] *= tintColor[0]; i++;
						imageData[i] *= tintColor[1]; i++;
						imageData[i] *= tintColor[2]; i++;
						imageData[i] *= tintColor[3]; i++;
					}
				}
				break;
			}
			case "tintblend": {
				let i = 0, tintColor = extractRGBA2(effectParams[0].value, Math.max(0, Math.min(1, +effectParams[1].value / 100)));
				if (tintColor[3] === 0) {} else if (tintColor[3] === 100) {
					for (; i < len;) {
						imageData[i] = tintColor[0]; i++;
						imageData[i] = tintColor[1]; i++;
						imageData[i] = tintColor[2]; i++;
						imageData[i] = 255; i++;
					}
				} else {
					for (; i < len;) {
						imageData[i] = interpolate(imageData[i], tintColor[0], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], tintColor[1], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], tintColor[2], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], 255, tintColor[3]); i++;
					}
				}
				break;
			}
			case "shift": {
				let i = 0, shift = -Math.round(+effectParams[0].value) * (effectParams[4].checked ? 4 : 1), colorPadding = extractRGBA2(effectParams[1].value, Math.max(0, Math.min(255, +effectParams[2].value * 255)));
				if (effectParams[3].checked) {
					if (shift === 0) {} else if (shift < 0) {
						for (i = len - 1; i >= 0;) {
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
						}
					} else {
						for (i = 0; i < len;) {
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
						}
					}
				} else {
					if (shift === 0) {} else if (shift < 0) {
						for (i = len - 1; i >= 0;) {
							if (i + shift < 0) {
								i -= 4;
								continue;
							}
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
						}
						for (i = -shift - 1; i >= 0;) {
							imageData[i] = colorPadding[3]; i--;
							imageData[i] = colorPadding[2]; i--;
							imageData[i] = colorPadding[1]; i--;
							imageData[i] = colorPadding[0]; i--;
						}
					} else {
						for (i = 0; i < len;) {
							if (i + shift > len) {
								i += 4;
								continue;
							}
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
						}
						for (i = len - shift; i < len;) {
							imageData[i] = colorPadding[0]; i++;
							imageData[i] = colorPadding[1]; i++;
							imageData[i] = colorPadding[2]; i++;
							imageData[i] = colorPadding[3]; i++;
						}
					}
				}
				break;
			}
			case "backg": {
				let i = 0, bgColor = extractRGBA2(effectParams[0].value, 100);
				for (i = 0; i < len;) {
					imageData[i] = interpolate(imageData[i], bgColor[0], (255 - imageData[i + 3]) / 255); i++;
					imageData[i] = interpolate(imageData[i], bgColor[1], (255 - imageData[i + 2]) / 255); i++;
					imageData[i] = interpolate(imageData[i], bgColor[2], (255 - imageData[i + 1]) / 255); i++;
					imageData[i] = 255; i++;
				}
				break;
			}
			case "restore": {
				context.clearRect(0, 0, +canvas.width, +canvas.height);
				canvas.width = +backupImageData.width;
				canvas.height = +backupImageData.height;
				currentImageData = new ImageData(new Uint8ClampedArray(backupImageData.data), backupImageData.width, backupImageData.height);
				break;
			}
			case "gblur": {
				currentImageData = applyGaussianBlur(currentImageData, generateGaussianKernel(Math.max(0.1, Math.min(2, +effectParams[1].value)), Math.max(1, Math.min(29, Math.round(+effectParams[0].value / 2) * 2 + 1))));
				break;
			}
			case "crop": {
				const xStart = Math.max(0, Math.min(currentImageData.width, +effectParams[0].value));
				const yStart = Math.max(0, Math.min(currentImageData.height, +effectParams[1].value));
				const xEnd = Math.max(0, Math.min(currentImageData.width, +effectParams[0].value + +effectParams[2].value));
				const yEnd = Math.max(0, Math.min(currentImageData.height, +effectParams[1].value + +effectParams[3].value));
				const croppedWidth = xEnd - xStart;
				const croppedHeight = yEnd - yStart;
				const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);
				let index = 0;
				for (let y = yStart; y < yEnd; y++) {
					for (let x = xStart; x < xEnd; x++) {
						let srcIndex = (y * currentImageData.width + x) * 4;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
					}
				}
				context.clearRect(0, 0, canvas.width, canvas.height);
				canvas.width = croppedWidth;
				canvas.height = croppedHeight;
				currentImageData = new ImageData(croppedData, croppedWidth, croppedHeight);
				effects.selectedIndex = 0;
				chooseEffect();
				break;
			}
			case "inv": {
				let i = 0, invert = +effectParams[0].value * 2.55;
				for (i = 0; i < len;) {
					imageData[i] = invert - imageData[i]; i++;
					imageData[i] = invert - imageData[i]; i++;
					imageData[i] = invert - imageData[i]; i += 2;
				}
				break;
			}
			case "sharpg": {
				const cur = applyGaussianBlur(currentImageData, generateGaussianKernel(Math.max(0.1, Math.min(2, +effectParams[1].value)), Math.max(1, Math.min(29, Math.round(+effectParams[0].value / 2) * 2 + 1)))).data;
				for (let i = 0; i < len;) {
					imageData[i] = (imageData[i] - cur[i]) * 2; i++;
					imageData[i] = (imageData[i] - cur[i]) * 2; i++;
					imageData[i] = (imageData[i] - cur[i]) * 2; i += 2;
				}
				break;
			}
			case "sepia": {
				let r, g, b, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					r = imageData[i]; g = imageData[i + 1]; b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], Math.min(255, (0.393 * r) + (0.769 * g) + (0.189 * b)), prog); i++;
					imageData[i] = interpolate(imageData[i], Math.min(255, (0.349 * r) + (0.686 * g) + (0.168 * b)), prog); i++;
        				imageData[i] = interpolate(imageData[i], Math.min(255, (0.272 * r) + (0.534 * g) + (0.131 * b)), prog); i += 2;
				}
				break;
			}
			case "graya": {
				let res, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					res = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
					imageData[i] = interpolate(imageData[i], res, prog); i++;
					imageData[i] = interpolate(imageData[i], res, prog); i++;
        				imageData[i] = interpolate(imageData[i], res, prog); i += 2;
				}
				break;
			}
			case "resi": {
				const image = new Image();
				image.onload = function() {
					image.onload = function() {};
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					canvas.width = +effectParams[0].value;
					canvas.height = +effectParams[1].value;
					context.imageSmoothingEnabled = effectParams[2].checked;
					context.drawImage(image, 0, 0, +effectParams[0].value, +effectParams[1].value);
					currentImageData = context.getImageData(0, 0, +effectParams[0].value, +effectParams[1].value);
					context.imageSmoothingEnabled = true;
					image.src = "";
				}
				image.src = canvas.toDataURL("image/png");
				break;
			}
			case "grayb": {
				let brightness, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					brightness = (0.34 * imageData[i]) + (0.5 * imageData[i + 1]) + (0.16 * imageData[i + 2]);
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i += 2;
				}
				break;
			}
			case "contr": {
				const contr = +effectParams[0].value + 1;
				if (contr === 0) {
					for (let i = 0; i < len;) {
						imageData[i] = 0; i++;
						imageData[i] = 0; i++;
						imageData[i] = 0; i += 2;
					}
				} else {
					for (let i = 0; i < len;) {
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i++;
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i++;
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i += 2;
					}
				}
				break;
			}
			case "flipy": {
				const a = new Uint8ClampedArray(imageData.length), rowSize = 4 * currentImageData.width, hei = currentImageData.height;
				let sourceRowIndex, destRowindex;
				for (let y = 0; y < hei; y++) {
					sourceRowIndex = (currentImageData.height - 1 - y) * rowSize;
					destRowIndex = y * rowSize;
					for (let x = 0; x < rowSize; x++) {
						a[destRowIndex + x] = imageData[sourceRowIndex + x];
					}
				}
				imageData.set(a);
				break;
			}
			case "flipx": {
				const newData = new Uint8ClampedArray(imageData.length), casa = currentImageData.width * 4
				let mirroredX, mirrorCache, mirrorETarg;
				for (let y = 0; y < len; y += casa) {
					for (let x = 0; x < casa; x += 4) {
						mirroredX = casa - x - 4;
						mirrorCache = y + mirroredX, mirrorTarg = y + x;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg];
					}
				}
				imageData.set(newData);
				break;
			}
			case "parag": {
				canvas.width = effectParams[0].value;
				canvas.height = effectParams[1].value;
				const requiredSize = +effectParams[0].value * +effectParams[1].value * 4;
				let deeea = new Uint8ClampedArray(requiredSize);
				deeea.set(imageData.slice(0, Math.min(requiredSize, len)));
				currentImageData = new ImageData(deeea, +canvas.width, +canvas.height);
				break;
			}
			case "rgbsh": {
				let i = 0, prog = +effectParams[0].value / 100, r, g, b;
				for (i = 0; i < len;) {
					r = imageData[i];
					g = imageData[i + 1];
					b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], g, prog); i++;
					imageData[i] = interpolate(imageData[i], b, prog); i++;
					imageData[i] = interpolate(imageData[i], r, prog); i += 2;
				}
				break;
			}
			case "rgbre": {
				let i = 0, prog = +effectParams[0].value / 100, r, g, b;
				for (i = 0; i < len;) {
					r = imageData[i];
					g = imageData[i + 1];
					b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], b, prog); i++;
					imageData[i] = interpolate(imageData[i], g, prog); i++;
					imageData[i] = interpolate(imageData[i], r, prog); i += 2;
				}
				break;
			}
			case "grayc": {
				let brightness, prog = +effectParams[0].value / 100, r = +effectParams[1].value / 100, g = +effectParams[2].value / 100, b = +effectParams[3].value / 100;
				for (let i = 0; i < len;) {
					brightness = (r * imageData[i]) + (g * imageData[i + 1]) + (b * imageData[i + 2]);
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i += 2;
				}
				break;
			}
			case "resid": {
				canvas.width = +effectParams[0].value;
				canvas.height = +effectParams[1].value;

				// Not all browsers have the same behavior of handling direct dimension changes, so we'll clear the canvas, then put the image data
				context.clearRect(0, 0, +effectParams[0].value, +effectParams[1].value);
				break;
			}
			case "opac": {
				let op = effectParams[1].checked ? +effectParams[0].value : Math.floor(255 - +effectParams[0].value * 2.55);
				if (effectParams[1].checked) {
					for (let i = 3; i < len; i += 4) {
						imageData[i] *= op;
					}
				} else {
					for (let i = 3; i < len; i += 4) {
						imageData[i] = op;
					}
				}
				break;
			}
			case "webp":
			case "jpeg": {
				const quality = Math.min(1, Math.max(0, Math.round(+effectParams[0].value) / 100));
				if (quality !== 1) {
					const image = new Image();
					image.onload = function() {
						image.onload = function() {};
						context.drawImage(image, 0, 0, +canvas.width, +canvas.height);
						currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
						image.src = "";
					}
					image.src = canvas.toDataURL("image/" + effects.value, quality);
				}
				break;
			}
			case "minip": {
				let op = +effectParams[0].value, i = 0;
				for (; i < len;) {
					imageData[i] = Math.round(imageData[i] / op) * op; i++;
					imageData[i] = Math.round(imageData[i] / op) * op; i++;
					imageData[i] = Math.round(imageData[i] / op) * op; i += 2;
				}
				break;
			}
			case "rect": {
				context.fillStyle = "rgba(" + extractRGBA2(effectParams[4].value, Math.max(0, Math.min(1, +effectParams[5].value))).join(", ") + ")";
				context.fillRect(+effectParams[0].value, +effectParams[1].value, +effectParams[2].value, +effectParams[3].value);
				currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
				context.fillStyle = "";
				break;
			}
			case "jpegd": {
				if (+effectParams[0].value < 0.4) {
					if (!confirm("THIS IMAGE EFFECT MAY CAUSE A SEIZURE FOR THOSE WITH EPILEPSY CONDITIONS FOR RAPID INTERVAL RATES. ARE YOU SURE YOU WANT TO ENABLE THIS?")) break;
				}
				if (+canvas.width > 1000 && +canvas.height > 1000) alert("The fascinating effect must require the image to be smaller than the current dimensions."); else {
					if (+effectParams[0].value < 0.05) alert("PERFORMANCE WARNING: It is not recommended to use intervals with that pausing time! Performance degradations can easily occur, and effects can sometimes overlap with each other, breaking functionality for the time of this animation (10 seconds).");
					const int = setInterval(function() {
						// 15, 16
						effects.selectedIndex = Math.random() < 0.333333 ? (15 + Math.round(Math.random())) : (Math.random() < 0.5 ? 4 : 23 + Math.round(Math.random()));
						if (effects.selectedIndex === 23 || effects.selectedIndex === 24) {
							effects.value = effects.selectedIndex === 23 ? "jpeg" : "webp";
							effectSettings.innerHTML = "<a>Quality:</a><input type=\"number\" id=\"e-jpegq\">";
							effectParams = [document.getElementById("e-jpegq")];
							effectParams[0].value = Math.round(Math.random() * 40);
						} else if (effects.selectedIndex === 4) {
							effects.value = "shift";
							effectSettings.innerHTML = "<a>Direction (in pixels. negative = leftwards, positive = rightwards):</a><input type=\"number\" value=\"0\" id=\"e-shiftdir\"><br><a>Color Padding:</a><input type=\"color\" value=\"#000000\" id=\"e-shiftcolor\"><br><a>Color Padding Opacity:</a><input type=\"number\" value=\"0\" min=\"0\" max=\"1\" step=\"0.00390625\" id=\"e-shiftopac\"><br><a>Wrap Around Image:</a><input type=\"checkbox\" id=\"e-shiftwrap\" checked><br><a>(if enabled) Pixel Level (if disabled) Integral Level:</a><input type=\"checkbox\" id=\"e-shiftint\" checked>";
							effectParams = [document.getElementById("e-shiftdir"), document.getElementById("e-shiftcolor"), document.getElementById("e-shiftopac"), document.getElementById("e-shiftwrap"), document.getElementById("e-shiftint")];
							effectParams[0].value = Math.round(4 - Math.random() * 8);
						} else chooseEffect();
						apply.click();
					}, Math.max(0, +effectParams[0].value) * 1000);
					setTimeout(function() {clearInterval(int)}, 10000);
				}
				break;
			}
			case "mp3": {
				if (typeof lamejs === "undefined") {
					const module = await fetch("lame.min.js");
					const code = await module.text();
					eval(code);
				}
				const pcmData = new Int16Array(imageData.length);
				for (let i = 0; i < len; i++) {
					pcmData[i] = (imageData[i] - 128) * 255; // Normalize to Int16 range
				}

				let mp3Encoder = new lamejs.Mp3Encoder(1, 44100, Math.floor(Math.max(16, Math.min(320, +effectParams[0].value)) / 16) * 16); // mono, 44.1kHz, 128kbps
				let mp3Data = [];
				let buffer = mp3Encoder.encodeBuffer(pcmData);
				mp3Data.push(new Uint8Array(buffer));
				buffer = null;

				//let finalBuffer = mp3Encoder.flush();
				//if (finalBuffer.length > 0) {
				//	mp3Data.push(finalBuffer);
				//}
				//finalBuffer = null;

				let mp3Blob = new Blob(mp3Data, { type: "audio/mpeg" });
				let mp3ArrayBuffer = await mp3Blob.arrayBuffer();
				mp3Blob = null;
				mp3Data = null;

				let audioContext = new (window.AudioContext || window.webkitAudioContext)();
				let audioBuffer = await audioContext.decodeAudioData(mp3ArrayBuffer);
				mp3ArrayBuffer = null;

				let decodedPCM = audioBuffer.getChannelData(0);
				audioBuffer = null;
				audioContext = null;
				
				const reconstructedImageData = new Uint8ClampedArray(imageData.length);
				const len2 = imageData.length;

				for (let i = 0, j = 0; i < len2; i += 2, j++;) {
					reconstructedImageData[j] = Math.min(255, Math.max(0, (1 + decodedPCM[i]) * 127.5));
				}
				decodedPCM = null;

				currentImageData = new ImageData(reconstructedImageData, currentImageData.width, currentImageData.height);
				console.log(currentImageData);
				break;
			}
		}
		context.putImageData(currentImageData, 0, 0);
		if (effects.value === "resid") currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
	}
	const css = document.getElementById("css"), bg = document.getElementById("bgcolor");
	bg.oninput = function() {
		css.textContent = `button, body, select, input {
	background-color: ${bg.value};
}
button, body, a, p, h1, select, option, input {
	color: ${extractRGBA2(bg.value, 0).reduce((a, b) => a + b) > 382 ? "black" : "white"};
}`;
	}
</script>
</body>
</html>
