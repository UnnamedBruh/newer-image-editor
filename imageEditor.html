<!DOCTYPE html>
<html lang="en">
<head>
<title>Image Editor</title>
<style>
button, body, select {
	background-color: rgb(40, 40, 40);
}
button, body, a, p, h1, select, option {
	color: white;
}
</style>
</head>
<body>
<h1>Image Editor</h1>
<input id="image" type="file" accept=".jfif, .jpeg, .jpg, .png, .webp, .gif, .bmp, .svg, .cur, .avif, .ico, .tga, .dds"><br><a>File Treaty Type:</a><select id="treatimage"><option value="att">Attempt to decode the image data</option><option value="asa">Assume the file data is raw RGBA image data</option><option value="asb">Assume the file data is raw RGB image data</option><option value="asd">Assume the file data is raw grayscale image data</option><option value="asv">Attempt to decode the video data (and extract any frame selected)</option></select>
<hr>
<canvas id="canvas" width="300" height="300"></canvas>
<hr>
<select id="effects"><option>Please select an effect.</option><option value="restore">Restore Image</option><option value="tint">Tint (Filter Color)</option><option value="tintblend">Tint (Blend Color)</option><option value="shift">Shift</option><option value="backg">Apply Background</option><option value="gblur">Gaussian Blur</option><option value="crop">Crop</option><option value="inv">Invert Colors</option><option value="sharpg">High Contrast</option><option value="sepia">Sepia</option><option value="graya">Grayscale (Average)</option><option value="grayb">Grayscale (By Brightness)</option><option value="contr">Contrast</option><option value="flipx">Flip Horizontally</option><option value="flipy">Flip Vertically</option><option value="rgbsh">Shift RGB Colors To The Left</option><option value="rgbre">Reverse Order Of RGB Colors</option><option value="resi">Resize Image</option><option value="parag">Resize Image Without Aligning Columns</option></select><button id="apply">Apply Effect</button>
<div id="configs"></div>
<script>
// tga.js
const TYPE_NO_DATA=0,TYPE_INDEXED=1,TYPE_RGB=2,TYPE_GREY=3,TYPE_RLE_INDEXED=9,TYPE_RLE_RGB=10,TYPE_RLE_GREY=11,ORIGIN_BOTTOM_LEFT=0,ORIGIN_BOTTOM_RIGHT=1,ORIGIN_TOP_LEFT=2,ORIGIN_TOP_RIGHT=3,ORIGIN_SHIFT=4,ORIGIN_MASK=48;class TgaLoader{_checkHeader(){const e=this.header;if(0===e.imageType)throw new Error("No data");if(e.hasColorMap){if(e.colorMapLength>256||24!==e.colorMapDepth||1!==e.colorMapType)throw new Error("Invalid colormap for indexed type")}else if(e.colorMapType)throw new Error("Why does the image contain a palette?");if(!e.width||!e.height)throw new Error("Invalid image size");if(8!==e.pixelDepth&&16!==e.pixelDepth&&24!==e.pixelDepth&&32!==e.pixelDepth)throw new Error('Invalid pixel size "'+e.pixelDepth+'"')}_decodeRLE(e,t,a,r){const o=new Uint8Array(r),i=new Uint8Array(a);let s=0;for(;s<r;){const r=e[t++];let h=1+(127&r);if(128&r){for(let r=0;r<a;++r)i[r]=e[t+r];t+=a;for(let e=0;e<h;++e)o.set(i,s),s+=a}else{h*=a;for(let a=0;a<h;++a)o[s+a]=e[t+a];s+=h,t+=h}}return o}_getImageData8bits(e,t,a,r,o,i,s,h,n,g){for(let l=0,p=o;p!==s;p+=i)for(let o=h;o!==g;o+=n,l++){const i=t[l];e[4*(o+r*p)+3]=255,e[4*(o+r*p)+2]=a[3*i+0],e[4*(o+r*p)+1]=a[3*i+1],e[4*(o+r*p)+0]=a[3*i+2]}return e}_getImageData16bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=2){const i=t[a+0]|t[a+1]<<8;e[4*(o+r*l)+0]=(31744&i)>>7,e[4*(o+r*l)+1]=(992&i)>>2,e[4*(o+r*l)+2]=(31&i)>>3,e[4*(o+r*l)+3]=32768&i?0:255}return e}_getImageData24bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=3)e[4*(o+r*l)+3]=255,e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+1]=t[a+1],e[4*(o+r*l)+0]=t[a+2];return e}_getImageData32bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=4)e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+1]=t[a+1],e[4*(o+r*l)+0]=t[a+2],e[4*(o+r*l)+3]=t[a+3];return e}_getImageDataGrey8bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a++){const i=t[a];e[4*(o+r*l)+0]=i,e[4*(o+r*l)+1]=i,e[4*(o+r*l)+2]=i,e[4*(o+r*l)+3]=255}return e}_getImageDataGrey16bits(e,t,a,r,o,i,s,h,n,g){for(let a=0,l=o;l!==s;l+=i)for(let o=h;o!==g;o+=n,a+=2)e[4*(o+r*l)+0]=t[a+0],e[4*(o+r*l)+1]=t[a+0],e[4*(o+r*l)+2]=t[a+0],e[4*(o+r*l)+3]=t[a+1];return e}open(e,t){const a=new XMLHttpRequest;a.responseType="arraybuffer",a.open("GET",e,!0),a.onload=()=>{200===a.status&&(this.load(new Uint8Array(a.response)),t&&t())},a.send(null)}load(e){let t=0;if(e.length<18)throw new Error("Not enough data to contain header");const a={idLength:e[t++],colorMapType:e[t++],imageType:e[t++],colorMapIndex:e[t++]|e[t++]<<8,colorMapLength:e[t++]|e[t++]<<8,colorMapDepth:e[t++],offsetX:e[t++]|e[t++]<<8,offsetY:e[t++]|e[t++]<<8,width:e[t++]|e[t++]<<8,height:e[t++]|e[t++]<<8,pixelDepth:e[t++],flags:e[t++]};if(a.hasEncoding=9===a.imageType||10===a.imageType||11===a.imageType,a.hasColorMap=9===a.imageType||1===a.imageType,a.isGreyColor=11===a.imageType||3===a.imageType,this.header=a,this._checkHeader(),t+=a.idLength,t>=e.length)throw new Error("No data");if(a.hasColorMap){const r=a.colorMapLength*(a.colorMapDepth>>3);this.palette=e.subarray(t,t+r),t+=r}const r=a.pixelDepth>>3,o=a.width*a.height,i=o*r;a.hasEncoding?this.imageData=this._decodeRLE(e,t,r,i):this.imageData=e.subarray(t,t+(a.hasColorMap?o:i))}getImageData(e){const{width:t,height:a,flags:r,pixelDepth:o,isGreyColor:i}=this.header,s=(48&r)>>4;let h,n,g,l,p,c,d;switch(e||(e=document?document.createElement("canvas").getContext("2d").createImageData(t,a):{width:t,height:a,data:new Uint8ClampedArray(t*a*4)}),2===s||3===s?(l=0,p=1,c=a):(l=a-1,p=-1,c=-1),2===s||0===s?(h=0,n=1,g=t):(h=t-1,n=-1,g=-1),o){case 8:d=i?this._getImageDataGrey8bits:this._getImageData8bits;break;case 16:d=i?this._getImageDataGrey16bits:this._getImageData16bits;break;case 24:d=this._getImageData24bits;break;case 32:d=this._getImageData32bits}return d.call(this,e.data,this.imageData,this.palette,t,l,p,c,h,n,g),e}getCanvas(){const{width:e,height:t}=this.header,a=document.createElement("canvas"),r=a.getContext("2d"),o=r.createImageData(e,t);return a.width=e,a.height=t,r.putImageData(this.getImageData(o),0,0),a}getDataURL(e){return this.getCanvas().toDataURL(e||"image/png")}};

// dds.js
const gl=document.createElement("canvas").getContext("webgl"),DDSF_CAPS=1,DDSF_HEIGHT=2,DDSF_WIDTH=4,DDSF_PIXELFORMAT=4096,DDSF_MIPMAPCOUNT=131072,DDSF_FOURCC=4,DDSF_RGBA=65,DDSF_RGB=64,FOURCC_DXT1=827611204,FOURCC_DXT5=894720068,FOURCC_R8G8B8=20,FOURCC_RGB32=1145194322,FOURCC_RGBA32=1178748754,FOURCC_RGB24=910313298,DDS_MAGIC="DDS ",DDS_HEADER={size:0,flags:0,height:0,width:0,pitchOrLinearSize:0,depth:0,mipMapCount:0,pf_size:0,pf_flags:0,pf_fourCC:0,pf_rgbBitCount:0,pf_rMask:0,pf_gMask:0,pf_bMask:0,pf_aMask:0,caps1:0,caps2:0},format=(t,e,r,a)=>({format:t,internal_format:e,type:r,bytesPerElement:a,compressed:!1}),compressedFormat=(t,e)=>({format:t,internal_format:t,type:t,bytesPerElement:e,compressed:!0}),fourcc_formats={827611204:compressedFormat(gl.COMPRESSED_RGBA_S3TC_DXT1_EXT,8),894720068:compressedFormat(gl.COMPRESSED_RGBA_S3TC_DXT5_EXT,16),20:format(gl.BGR,gl.RGB8,gl.UNSIGNED_BYTE,3),1145194322:format(gl.RGB,gl.RGBA8,gl.UNSIGNED_BYTE,4),1178748754:format(gl.RGBA,gl.RGBA8,gl.UNSIGNED_BYTE,4),910313298:format(gl.BGR,gl.RGB8,gl.UNSIGNED_BYTE,3)};function parseDDS(t){let e={};if(!(t instanceof ArrayBuffer))throw new Error("Expected ArrayBuffer");const r=new Uint8Array(t);if("DDS "!==(new TextDecoder).decode(r.slice(0,4)))throw new Error("Not a valid DDS file");const a=unpackDDSHeader(r);let f=4+DDS_HEADER.size;e.width=a.width,e.height=a.height,e.depth=1&a.caps2?a.depth:0,e.levels=131072&a.flags?a.mipMapCount:1;let o=null;if(4&a.pf_flags?o=fourcc_formats[a.pf_fourCC]:65===a.pf_flags&&32===a.pf_rgbBitCount?o=fourcc_formats[1178748754]:64===a.pf_flags&&32===a.pf_rgbBitCount?o=fourcc_formats[1145194322]:64===a.pf_flags&&24===a.pf_rgbBitCount&&(o=fourcc_formats[910313298]),!o)throw new Error("Unknown or unsupported DDS format");Object.assign(e,o),e.parts=[];let s=e.width,n=e.height,_=e.depth||1;for(let t=0;t<e.levels;t++){const t=Math.max(1,Math.floor(s/2))*Math.max(1,Math.floor(n/2))*_*e.bytesPerElement;e.parts.push({offset:f,size:t}),f+=t,s=Math.max(1,Math.floor(s/2)),n=Math.max(1,Math.floor(n/2))}return e}function unpackDDSHeader(t){const e=new DataView(t.buffer);return{width:e.getUint32(4,!0),height:e.getUint32(8,!0),flags:e.getUint32(12,!0),pf_flags:e.getUint32(20,!0),pf_fourCC:e.getUint32(84,!0),pf_rgbBitCount:e.getUint32(28,!0),mipMapCount:e.getUint32(104,!0),caps1:e.getUint32(108,!0),caps2:e.getUint32(112,!0),size:e.getUint32(0,!0)}}

function loadTgaFromUint8Array(tgaData) {
	let buffer, image;
	try {
		const loader = new TgaLoader();
		loader.load(tgaData);
		image = loader.imageData;
		const possibleInstructions = [
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_BOTTOM_LEFT,
				"flip the image vertically."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_BOTTOM_RIGHT,
				"flip the image horizontally, and flip the image vertically."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_TOP_LEFT,
				"reverse the color channels' order, or shift the color channels' to the left repeatedly until the image's color feels right to you."
			],
			[
				(loader.header.flags & ORIGIN_MASK) === ORIGIN_TOP_RIGHT,
				"flip the image horizontally."
			]
		];
		let instructions = possibleInstructions.find(x => x[0])[1];
		alert("Proper handling for the TGA origins and different color orders will come in a future update. For now, you must " + instructions + (instructions === "reverse the color channels' order, or shift the color channels' to the left repeatedly until the image's color feels right to you." ? "" : " You may also need to shift the color channels until the image's color feels right to you."));
		if (loader.header.pixelDepth === 24) {
			buffer = new Uint8ClampedArray(loader.header.width * loader.header.height * 4);
			for (let i = 0, j = 0; i < buffer.length;) {
				buffer[i] = image[j]; i++, j++;
				buffer[i] = image[j]; i++, j++;
				buffer[i] = image[j]; i++, j++;
				buffer[i] = 255; i++;
			}
			return new ImageData(
				buffer,
				loader.header.width,
				loader.header.height
			);
		} else if (loader.header.pixelDepth === 32) {
			return new ImageData(
				image,
				loader.header.width,
				loader.header.height
			);
		}
	} catch (err) {
		alert("There has been an error trying to decode the TGA image: " + err.message);
		if (tgaData.length === 0) alert("The TGA image contains no file data at all. This is needed to provide the context of the image (e.g. the width, height, color channels, etc), and the image data itself.");
		else if ((loader.header.pixelDepth === 24 && image.length !== loader.header.width * loader.header.height * 3) || (loader.header.pixelDepth === 32 && image.length !== loader.header.width * loader.header.height * 4)) alert("There appears to be an image data overflow (providing too many pixel values) or underflow (providing too little pixel values). This has to be fixed, so the image can correctly be loaded next time.");
		else if ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
			if (confirm("The TGA image has a very odd specification of the pixel depth (provided was " + loader.header.pixelDepth + ", expected was 8, 16, 24, or 32). Do you want to provide the pixel depth?")) {
				//16
				let pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
				if ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
					while ([8, 16, 24, 32].indexOf(loader.header.pixelDepth) === -1) {
						alert("That level isn't recommended; you need to specify again.");
						pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
					}
				}
				tgaData[16] = Math.round(pixelDepth & 256);
				loadTgaFromUint8Array(tgaData);
			}
		}
	}
}

function loadDdsFromUint8Array(ddsData) {
	let buffer, image;
	try {
		const loader = parseDDS(ddsData);
		image = loader.parts[Math.floor(Math.max(0, Math.min(result.parts.length - 1, +prompt("Select a mipmap to be chosen for the imported image (there are " + loader.parts.length + " mipmaps left. select an index that is zero-based)") || 0)))];
		if (loader.pf_rgbBitCount === 24 && (loader.format === gl.BGR && loader.internal_format === gl.RGB8)) {
			buffer = new Uint8ClampedArray(loader.header.width * loader.header.height * 4);
			let i = 0;
			for (let j = 0; i < buffer.length; j += 3) {
				buffer[i] = image[j + 2]; i++;
				buffer[i] = image[j + 1]; i++;
				buffer[i] = image[j]; i++;
				buffer[i] = 255; i++;
			}
			return new ImageData(
				buffer,
				loader.header.width,
				loader.header.height
			);
		} else if (loader.pf_rgbBitCount === 32 && (loader.format === gl.RGB && loader.internal_format === gl.RGBA8)) {
			return new ImageData(
				image,
				loader.header.width,
				loader.header.height
			);
		} else {
			alert("Unknown colorspace for the DDS image - this case will be handled in the future");
		}
	} catch (err) {
		alert("There has been an error trying to decode the DDS image: " + err.message);
		if (tgaData.length === 0) alert("The DDS image contains no file data at all. This is needed to provide the context of the image (e.g. the width, height, color channels, etc), and the image data itself.");
		else if ((loader.pf_rgbBitCount === 24 && image.length !== loader.width * loader.height * 3) || (loader.pf_rgbBitCount === 32 && image.length !== loader.width * loader.height * 4)) alert("There appears to be an image data overflow (providing too many pixel values) or underflow (providing too little pixel values). This has to be fixed, so the image can correctly be loaded next time.");
		else if ([24, 32].indexOf(loader.pf_rgbBitCount) === -1) {
			if (confirm("The DDS image has a very odd specification of the pixel depth (provided was " + loader.pf_rgbBitCount + ", expected was 24, or 32). Do you want to provide the pixel depth?")) {
				//16
				let pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
				if ([24, 32].indexOf(loader.header.pixelDepth) === -1) {
					while ([24, 32].indexOf(loader.header.pixelDepth) === -1) {
						alert("That level isn't recommended; you need to specify again.");
						pixelDepth = +prompt("Provide the pixel depth (the default is 24).") || 24;
					}
				}
				ddsData[28] = Math.round(pixelDepth & 256);
				ddsData[29] = 0;
				ddsData[30] = 0;
				ddsData[31] = 0;
				loadTgaFromUint8Array(ddsData);
			}
		}
	}
}

const fileInput = document.getElementById("image"), treatFile = document.getElementById("treatimage"), canvas = document.getElementById("canvas"), effects = document.getElementById("effects"), applyEffect = document.getElementById("apply"), effectSettings = document.getElementById("configs");
const context = canvas.getContext("2d");
if (!context) {
	alert("Your browser does not support the 2D canvas context yet. Either upgrade to a newer version of your browser, or try using a different one.");
}
	let currentImageData = new ImageData(new Uint8ClampedArray(300 * 300 * 4), 300, 300), backupImageData = new ImageData(new Uint8ClampedArray(300 * 300 * 4), 300, 300), originalImage;
	fileInput.addEventListener("input", function(event) {
		const file = event.target.files[0];
		let fileReader = new FileReader();
		fileReader.onload = function(res) {
			if (treatFile.value === "att") {
				if (file.name.endsWith(".tga")) {
					alert("TGA.js is being used to decode the image.");
					currentImageData = loadTgaFromUint8Array(new Uint8Array(res.target.result));
					backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
					canvas.width = currentImageData.width;
					canvas.height = currentImageData.height;
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					context.putImageData(currentImageData, 0, 0);
				} else if (file.name.endsWith(".dds")) {
					alert("DDS.js (browser port) is being used to decode the image.");
					currentImageData = loadDdsFromUint8Array(new Uint8Array(res.target.result));
					backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
					canvas.width = currentImageData.width;
					canvas.height = currentImageData.height;
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					context.putImageData(currentImageData, 0, 0);
				} else {
					const img = new Image();
					img.onload = function() {
						canvas.width = img.width;
						canvas.height = img.height;
						context.clearRect(0, 0, +canvas.width, +canvas.height);
						context.drawImage(img, 0, 0, +canvas.width, +canvas.height);
						currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						originalImage = img;
					}
					img.src = res.target.result;
				}
			} else {
				if (treatFile.value !== "asv") {
					const width = Math.round(+(prompt("What should the width of the raw file data be for the final image? (The height is automatically determined. The default value is 300)") || 300));
					if (treatFile.value === "asa") {
						const height = Math.ceil(res.target.result.byteLength / width / 4);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4);
						roundedUint.set(new Uint8ClampedArray(res.target.result));
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					} else if (treatFile.value === "asb") {
						const height = Math.ceil(res.target.result.byteLength / width / 3);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4), buff = new Uint8ClampedArray(res.target.result);
						let byte = 0;
						for (let i = 0; i < roundedUint.byteLength;) {
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = buff[byte]; i++, byte++;
							roundedUint[i] = 255; i++;
						}
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					} else if (treatFile.value === "asd") {
						const height = Math.ceil(res.target.result.byteLength / width);
						canvas.width = width;
						canvas.height = height;
						const roundedUint = new Uint8ClampedArray(width * height * 4), buff = new Uint8ClampedArray(res.target.result);
						let first = 0;
						for (let i = 0; i < roundedUint.byteLength;) {
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = buff[first]; i++;
							roundedUint[i] = 255; i++; first++;
						}
						currentImageData = new ImageData(roundedUint, width, height);
						backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
						context.putImageData(currentImageData, 0, 0);
					}
				} else {
					fileInput.style.display = "none";
					const video = document.createElement("video");
					video.oncanplaythrough = function() {
						video.oncanplaythrough = function() {}
						setTimeout(function() {
							canvas.width = video.width;
							canvas.height = video.height;
							canvas.style.display = "none";
							context.clearRect(0, 0, +canvas.width, +canvas.height);
							video.ontimeupdate = function() {
								context.drawImage(video, 0, 0, +canvas.width, +canvas.height);
							}
							document.body.appendChild(video);
							const bounding = video.getBoundingClientRect();
							if (canvas.width == 0 || canvas.height == 0) {
								canvas.width = bounding.width;
								canvas.height = bounding.height;
							}
							video.controls = true;
							const confirm = document.createElement("button");
							confirm.textContent = "Select Frame";
							document.body.appendChild(confirm);
							confirm.onclick = function() {
								video.pause();
								video.muted = true;
								setTimeout(function() {
									canvas.style.display = "";
									currentImageData = context.getImageData(0, 0, +canvas.width, +canvas.height);
									backupImageData = new ImageData(new Uint8ClampedArray(currentImageData.data), currentImageData.width, currentImageData.height);
									const image = new Image();
									image.src = canvas.toDataURL("image/png");
									originalImage = image;
									video.src = "";
									video.remove();
									fileInput.style.display = "";
								}, 200);
							}
						}, 1000);
					}
					video.src = res.target.result;
				}
			}
		}
		if ((treatFile.value === "att" || treatFile.value === "asv") && !file.name.endsWith(".tga") && !file.name.endsWith(".dds")) fileReader.readAsDataURL(file); else fileReader.readAsArrayBuffer(file);
	});
	treatFile.oninput = function() {
		if (treatFile.value === "att") fileInput.accept = ".jfif, .jpeg, .jpg, .png, .webp, .gif, .bmp, .svg, .cur, .avif, .ico, .tga, .dds"; else if (treatFile.value === "asv") fileInput.accept = ".mp4, .ogg, .webm, .3gp"; else fileInput.accept = ".*";
	}
	let effectParams = [];
	function extractRGBA(hex, a) {
		const r = parseInt(hex.slice(1, 3), 16) / 255;
		const g = parseInt(hex.slice(3, 5), 16) / 255;
		const b = parseInt(hex.slice(5, 7), 16) / 255;
		return [r, g, b, a];
	}
	function extractRGBA2(hex, a) {
		const r = parseInt(hex.slice(1, 3), 16);
		const g = parseInt(hex.slice(3, 5), 16);
		const b = parseInt(hex.slice(5, 7), 16);
		return [r, g, b, a];
	}
	function interpolate(x, y, n) {
		return x + (y - x) * n;
	}
	function applyGaussianBlur(imageData, kernel) {
		const width = imageData.width;
		const height = imageData.height;
		const output = new ImageData(new Uint8ClampedArray(width * height * 4), width, height);
		const kernelSize = kernel.length;
		const halfKernel = Math.floor(kernelSize / 2);
		const data = output.data;
		let r, g, b, a, outputIndex, px, py, pixelIndex, weight;
		for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				r = 0, g = 0, b = 0, a = 0;
				for (let ky = 0; ky < kernelSize; ky++) {
					for (let kx = 0; kx < kernelSize; kx++) {
						px = x + kx - halfKernel;
						py = y + ky - halfKernel;
						if (px >= 0 && py >= 0 && px < width && py < height) {
							pixelIndex = (py * width + px) * 4;
							weight = kernel[ky][kx];
							r += imageData.data[pixelIndex] * weight; pixelIndex++;
							g += imageData.data[pixelIndex] * weight; pixelIndex++;
							b += imageData.data[pixelIndex] * weight; pixelIndex++;
							a += imageData.data[pixelIndex] * weight;
						}
					}
				}
				outputIndex = (y * width + x) * 4;
				data[outputIndex] = r; outputIndex++;
				data[outputIndex] = g; outputIndex++;
				data[outputIndex] = b; outputIndex++;
				data[outputIndex] = a;
			}
		}
		return output;
	}
	function generateGaussianKernel(sigma, size) {
		const kernel = [];
		const mean = Math.floor(size / 2);
		let sum = 0, dx, dy, value;
		for (let y = 0; y < size; y++) {
			kernel[y] = [];
			for (let x = 0; x < size; x++) {
				dx = x - mean;
				dy = y - mean;
				value = (1 / (2 * Math.PI * sigma * sigma)) * Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
				kernel[y][x] = value;
				sum += value;
			}
		}
		for (let y = 0; y < size; y++) {
			for (let x = 0; x < size; x++) {
				kernel[y][x] /= sum;
			}
		}
		return kernel;
	}
	function mod(x, y) {
		let result = x % y;
		return result < 0 ? result + y : result;
	}
	function chooseEffect() {
		effectSettings.innerHTML = "";
		if (effects.value === "tint") {
			effectSettings.innerHTML = "<a>Tint Color:</a><input type=\"color\" value=\"#FF0000\" id=\"e-tintcolor\"><br><a>Tint Opacity:</a><input type=\"number\" value=\"1\" min=\"0\" max=\"1\" step=\"0.00390625\" id=\"e-tintopac\"><br><a>Tint Multiplier:</a><input type=\"number\" value=\"1\" min=\"0\" max=\"255\" step=\"1\" id=\"e-tintmult\">";
			effectParams = [document.getElementById("e-tintcolor"), document.getElementById("e-tintopac"), document.getElementById("e-tintmult")];
		} else if (effects.value === "tintblend") {
			effectSettings.innerHTML = "<a>Tint Color:</a><input type=\"color\" value=\"#FF0000\" id=\"e-tintcolor\"><br><a>Blending Percentage:</a><input type=\"number\" value=\"20\" min=\"0\" max=\"100\" step=\"1\" id=\"e-tintopac\">";
			effectParams = [document.getElementById("e-tintcolor"), document.getElementById("e-tintopac")];
		} else if (effects.value === "shift") {
			effectSettings.innerHTML = "<a>Direction (in pixels. negative = leftwards, positive = rightwards):</a><input type=\"number\" value=\"0\" id=\"e-shiftdir\"><br><a>Color Padding:</a><input type=\"color\" value=\"#000000\" id=\"e-shiftcolor\"><br><a>Color Padding Opacity:</a><input type=\"number\" value=\"0\" min=\"0\" max=\"1\" step=\"0.00390625\" id=\"e-shiftopac\"><br><a>Wrap Around Image:</a><input type=\"checkbox\" id=\"e-shiftwrap\">";
			effectParams = [document.getElementById("e-shiftdir"), document.getElementById("e-shiftcolor"), document.getElementById("e-shiftopac"), document.getElementById("e-shiftwrap")];
		} else if (effects.value === "backg") {
			effectSettings.innerHTML = "<a>Background Color:</a><input type=\"color\" value=\"#000000\" id=\"e-backcolor\">";
			effectParams = [document.getElementById("e-backcolor")];
		} else if (effects.value === "gblur" || effects.value === "sharpg") {
			effectSettings.innerHTML = "<a>Kernel Size (Slight Blur Spread, and Smoothness):</a><input type=\"number\" value=\"3\" step=\"2\" min=\"1\" max=\"15\" id=\"e-gblurkernel\"><br><a>Sigma Value:</a><input type=\"number\" value=\"1\" step=\"0.1\" min=\"0\" max=\"100\" id=\"e-gblursigma\">";
			effectParams = [document.getElementById("e-gblurkernel"), document.getElementById("e-gblursigma")];
		} else if (effects.value === "crop") {
			effectSettings.innerHTML = "<a>X:</a><input type=\"number\" value=\"0\" id=\"e-cropx\"><br><a>Y:</a><input type=\"number\" value=\"0\" id=\"e-cropy\"><br><a>Width:</a><input type=\"number\" value=\"0\" id=\"e-cropw\"><br><a>Height:</a><input type=\"number\" value=\"0\" id=\"e-croph\"><br>";
			effectParams = [document.getElementById("e-cropx"), document.getElementById("e-cropy"), document.getElementById("e-cropw"), document.getElementById("e-croph")];
			for (const p of effectParams) {
				p.oninput = function() {
					p.value = String(Math.round(+p.value.trim()));
					context.clearRect(0, 0, currentImageData.width, currentImageData.height);
					context.putImageData(currentImageData, 0, 0);
					context.fillStyle = "rgba(255, 255, 255, 0.3)";
					context.fillRect(+effectParams[0].value, +effectParams[1].value, +effectParams[2].value, +effectParams[3].value);
				}
			}
		} else if (effects.value === "inv" || effects.value === "sepia" || effects.value === "graya" || effects.value === "grayb" || effects.value === "rgbsh" || effects.value === "rgbre") {
			effectSettings.innerHTML = "<a>Progress (as a percentage):</a><input type=\"number\" value=\"100\" step=\"0.390625\" min=\"0\" max=\"100\" id=\"e-invpro\">%";
			effectParams = [document.getElementById("e-invpro")];
		} else if (effects.value === "resi" || effects.value === "parag") {
			effectSettings.innerHTML = "<a>Width:</a><input type=\"number\" value=\"\" id=\"e-resiw\"><br><a>Height:</a><input type=\"number\" value=\"\" id=\"e-resih\">" + (effects.value === "resi" ? "<br><a>Anti-aliasing:</a><input type=\"checkbox\" checked id=\"e-resia\">" : "");
			effectParams = [document.getElementById("e-resiw"), document.getElementById("e-resih"), effects.value === "resi" ? document.getElementById("e-resia") : null];
			effectParams[0].value = canvas.width;
			effectParams[1].value = canvas.height;
		} else if (effects.value === "contr") {
			effectSettings.innerHTML = "<a>Contrast Level:</a><input type=\"number\" value=\"0.5\" step=\"0.02\" min=\"0\" max=\"10\" id=\"e-contr\">";
			effectParams = [document.getElementById("e-contr")];
		} else {
			effectSettings.innerHTML = "";
			effectParams = [];
		}
	}
	effects.oninput = chooseEffect;
	apply.onclick = function() {
		const imageData = currentImageData.data;
		let len = imageData.length;
		switch (effects.value) {
			case "tint": {
				let i = 0, tintColor = extractRGBA(effectParams[0].value, Math.max(0, Math.min(1, +effectParams[1].value)));
				tintColor = tintColor.map(x => x * +effectParams[2].value);
				if (tintColor[0] === 1 && tintColor[1] === 1 && tintColor[2] === 1) {
					if (tintColor[3] !== 1) {
						for (i = 3; i < len; i += 4) {
							imageData[i] *= tintColor[3];
						}
					}
				} else {
					for (; i < len;) {
						imageData[i] *= tintColor[0]; i++;
						imageData[i] *= tintColor[1]; i++;
						imageData[i] *= tintColor[2]; i++;
						imageData[i] *= tintColor[3]; i++;
					}
				}
				break;
			}
			case "tintblend": {
				let i = 0, tintColor = extractRGBA2(effectParams[0].value, Math.max(0, Math.min(1, +effectParams[1].value / 100)));
				if (tintColor[3] === 0) {} else if (tintColor[3] === 100) {
					for (; i < len;) {
						imageData[i] = tintColor[0]; i++;
						imageData[i] = tintColor[1]; i++;
						imageData[i] = tintColor[2]; i++;
						imageData[i] = 255; i++;
					}
				} else {
					for (; i < len;) {
						imageData[i] = interpolate(imageData[i], tintColor[0], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], tintColor[1], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], tintColor[2], tintColor[3]); i++;
						imageData[i] = interpolate(imageData[i], 255, tintColor[3]); i++;
					}
				}
				break;
			}
			case "shift": {
				let i = 0, shift = 0 - Math.round(+effectParams[0].value) * 4, colorPadding = extractRGBA2(effectParams[1].value, Math.max(0, Math.min(255, +effectParams[2].value * 255)));
				if (effectParams[3].checked) {
					if (shift === 0) {} else if (shift < 0) {
						for (i = len - 1; i >= 0;) {
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
							imageData[i] = imageData[mod(i + shift, len)]; i--;
						}
					} else {
						for (i = 0; i < len;) {
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
							imageData[i] = imageData[mod(i + shift, len)]; i++;
						}
					}
				} else {
					if (shift === 0) {} else if (shift < 0) {
						for (i = len - 1; i >= 0;) {
							if (i + shift < 0) {
								i -= 4;
								continue;
							}
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
							imageData[i] = imageData[i + shift]; i--;
						}
						for (i = -shift - 1; i >= 0;) {
							imageData[i] = colorPadding[3]; i--;
							imageData[i] = colorPadding[2]; i--;
							imageData[i] = colorPadding[1]; i--;
							imageData[i] = colorPadding[0]; i--;
						}
					} else {
						for (i = 0; i < len;) {
							if (i + shift > len) {
								i += 4;
								continue;
							}
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
							imageData[i] = imageData[i + shift]; i++;
						}
						for (i = len - shift; i < len;) {
							imageData[i] = colorPadding[0]; i++;
							imageData[i] = colorPadding[1]; i++;
							imageData[i] = colorPadding[2]; i++;
							imageData[i] = colorPadding[3]; i++;
						}
					}
				}
				break;
			}
			case "backg": {
				let i = 0, bgColor = extractRGBA2(effectParams[0].value, 100);
				for (i = 0; i < len;) {
					imageData[i] = interpolate(imageData[i], bgColor[0], (255 - imageData[i + 3]) / 255); i++;
					imageData[i] = interpolate(imageData[i], bgColor[1], (255 - imageData[i + 2]) / 255); i++;
					imageData[i] = interpolate(imageData[i], bgColor[2], (255 - imageData[i + 1]) / 255); i++;
					imageData[i] = 255; i++;
				}
				break;
			}
			case "restore": {
				context.clearRect(0, 0, +canvas.width, +canvas.height);
				canvas.width = +backupImageData.width;
				canvas.height = +backupImageData.height;
				currentImageData = new ImageData(new Uint8ClampedArray(backupImageData.data), backupImageData.width, backupImageData.height);
				break;
			}
			case "gblur": {
				currentImageData = applyGaussianBlur(currentImageData, generateGaussianKernel(Math.max(0.1, Math.min(2, +effectParams[1].value)), Math.max(1, Math.min(29, Math.round(+effectParams[0].value / 2) * 2 + 1))));
				break;
			}
			case "crop": {
				const xStart = Math.max(0, Math.min(currentImageData.width, +effectParams[0].value));
				const yStart = Math.max(0, Math.min(currentImageData.height, +effectParams[1].value));
				const xEnd = Math.max(0, Math.min(currentImageData.width, +effectParams[0].value + +effectParams[2].value));
				const yEnd = Math.max(0, Math.min(currentImageData.height, +effectParams[1].value + +effectParams[3].value));
				const croppedWidth = xEnd - xStart;
				const croppedHeight = yEnd - yStart;
				const croppedData = new Uint8ClampedArray(croppedWidth * croppedHeight * 4);
				let index = 0;
				for (let y = yStart; y < yEnd; y++) {
					for (let x = xStart; x < xEnd; x++) {
						let srcIndex = (y * currentImageData.width + x) * 4;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
						croppedData[index++] = currentImageData.data[srcIndex]; srcIndex++;
					}
				}
				context.clearRect(0, 0, canvas.width, canvas.height);
				canvas.width = croppedWidth;
				canvas.height = croppedHeight;
				currentImageData = new ImageData(croppedData, croppedWidth, croppedHeight);
				effects.selectedIndex = 0;
				chooseEffect();
				break;
			}
			case "inv": {
				let i = 0, invert = +effectParams[0].value * 2.55;
				for (i = 0; i < len;) {
					imageData[i] = invert - imageData[i]; i++;
					imageData[i] = invert - imageData[i]; i++;
					imageData[i] = invert - imageData[i]; i += 2;
				}
				break;
			}
			case "sharpg": {
				const cur = applyGaussianBlur(currentImageData, generateGaussianKernel(Math.max(0.1, Math.min(2, +effectParams[1].value)), Math.max(1, Math.min(29, Math.round(+effectParams[0].value / 2) * 2 + 1)))).data;
				for (let i = 0; i < len;) {
					imageData[i] = (imageData[i] - cur[i]) * 2; i++;
					imageData[i] = (imageData[i] - cur[i]) * 2; i++;
					imageData[i] = (imageData[i] - cur[i]) * 2; i += 2;
				}
				break;
			}
			case "sepia": {
				let r, g, b, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					r = imageData[i]; g = imageData[i + 1]; b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], Math.min(255, (0.393 * r) + (0.769 * g) + (0.189 * b)), prog); i++;
					imageData[i] = interpolate(imageData[i], Math.min(255, (0.349 * r) + (0.686 * g) + (0.168 * b)), prog); i++;
        				imageData[i] = interpolate(imageData[i], Math.min(255, (0.272 * r) + (0.534 * g) + (0.131 * b)), prog); i += 2;
				}
				break;
			}
			case "graya": {
				let res, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					res = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
					imageData[i] = interpolate(imageData[i], res, prog); i++;
					imageData[i] = interpolate(imageData[i], res, prog); i++;
        				imageData[i] = interpolate(imageData[i], res, prog); i += 2;
				}
				break;
			}
			case "resi": {
				const image = new Image();
				image.src = canvas.toDataURL("image/png");
				image.onload = function() {
					image.onload = function() {};
					context.clearRect(0, 0, +canvas.width, +canvas.height);
					canvas.width = +effectParams[0].value;
					canvas.height = +effectParams[1].value;
					context.imageSmoothingEnabled = effectParams[2].checked;
					context.drawImage(image, 0, 0, +effectParams[0].value, +effectParams[1].value);
					currentImageData = context.getImageData(0, 0, +effectParams[0].value, +effectParams[1].value);
					context.imageSmoothingEnabled = true;
					image.src = "";
				}
				break;
			}
			case "grayb": {
				let brightness, prog = +effectParams[0].value / 100;
				for (let i = 0; i < len;) {
					brightness = (0.34 * imageData[i]) + (0.5 * imageData[i + 1]) + (0.16 * imageData[i + 2]);
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i++;
					imageData[i] = interpolate(imageData[i], brightness, prog); i += 2;
				}
				break;
			}
			case "contr": {
				const contr = +effectParams[0].value + 1;
				if (contr === 0) {
					for (let i = 0; i < len;) {
						imageData[i] = 0; i++;
						imageData[i] = 0; i++;
						imageData[i] = 0; i += 2;
					}
				} else {
					for (let i = 0; i < len;) {
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i++;
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i++;
						imageData[i] = interpolate(0, 255, Math.pow(imageData[i] / 255, contr)); i += 2;
					}
				}
				break;
			}
			case "flipy": {
				const a = new Uint8ClampedArray(imageData.length), rowSize = 4 * currentImageData.width, hei = currentImageData.height;
				let sourceRowIndex, destRowindex;
				for (let y = 0; y < hei; y++) {
					sourceRowIndex = (currentImageData.height - 1 - y) * rowSize;
					destRowIndex = y * rowSize;
					for (let x = 0; x < rowSize; x++) {
						a[destRowIndex + x] = imageData[sourceRowIndex + x];
					}
				}
				imageData.set(a);
				break;
			}
			case "flipx": {
				const newData = new Uint8ClampedArray(imageData.length), casa = currentImageData.width * 4
				let mirroredX, mirrorCache, mirrorETarg;
				for (let y = 0; y < len; y += casa) {
					for (let x = 0; x < casa; x += 4) {
						mirroredX = casa - x - 4;
						mirrorCache = y + mirroredX, mirrorTarg = y + x;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg]; mirrorCache++, mirrorTarg++;
						newData[mirrorCache] = imageData[mirrorTarg];
					}
				}
				imageData.set(newData);
				break;
			}
			case "parag": {
				canvas.width = effectParams[0].value;
				canvas.height = effectParams[1].value;
				const requiredSize = +effectParams[0].value * +effectParams[1].value * 4;
				let deeea = new Uint8ClampedArray(requiredSize);
				deeea.set(imageData.slice(0, Math.min(requiredSize, imageData.length)));
				currentImageData = new ImageData(deeea, +canvas.width, +canvas.height);
				break;
			}
			case "rgbsh": {
				let i = 0, prog = +effectParams[0].value / 100, r, g, b;
				for (i = 0; i < len;) {
					r = imageData[i];
					g = imageData[i + 1];
					b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], g, prog); i++;
					imageData[i] = interpolate(imageData[i], b, prog); i++;
					imageData[i] = interpolate(imageData[i], r, prog); i += 2;
				}
				break;
			}
			case "rgbre": {
				let i = 0, prog = +effectParams[0].value / 100, r, g, b;
				for (i = 0; i < len;) {
					r = imageData[i];
					g = imageData[i + 1];
					b = imageData[i + 2];
					imageData[i] = interpolate(imageData[i], b, prog); i++;
					imageData[i] = interpolate(imageData[i], g, prog); i++;
					imageData[i] = interpolate(imageData[i], r, prog); i += 2;
				}
				break;
			}
		}
		context.putImageData(currentImageData, 0, 0);
	}
</script>
</body>
</html>
